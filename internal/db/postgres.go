package db

import (
	"database/sql"
	"fmt"
	"log"
	"time"
)

// PostgresManager handles all interactions with the PostgreSQL database.
// It provides methods for managing sales, checkout attempts, and purchases,
// ensuring data persistence and integrity for the flash-sale service.
type PostgresManager struct {
	DB *sql.DB // DB is the underlying *sql.DB connection pool.
}

// NewPostgresManager creates and returns a new instance of PostgresManager.
// It takes an initialized *sql.DB connection as an argument.
func NewPostgresManager(db *sql.DB) *PostgresManager {
	return &PostgresManager{
		DB: db,
	}
}

// InitializeTables creates the `sales`, `checkout_attempts`, and `purchases`
// tables in the PostgreSQL database if they do not already exist.
// This function is idempotent and safe to call on application startup.
//
// Returns:
//
//	error: An error if any table creation fails, otherwise nil.
func (pm *PostgresManager) InitializeTables() error {
	// SQL statement to create the 'sales' table.
	// It stores information about each flash sale, including its start and end times.
	_, err := pm.DB.Exec(`
		CREATE TABLE IF NOT EXISTS sales (
			id SERIAL PRIMARY KEY,
			created_at TIMESTAMP NOT NULL DEFAULT NOW(),
			ended_at TIMESTAMP
		)
	`)
	if err != nil {
		log.Printf("Failed to create sales table: %v", err)
		return fmt.Errorf("failed to create sales table: %w", err)
	}

	// SQL statement to create the 'checkout_attempts' table.
	// This table records every attempt a user makes to checkout an item,
	// associating it with a unique code and tracking if it has been used.
	_, err = pm.DB.Exec(`
		CREATE TABLE IF NOT EXISTS checkout_attempts (
			id SERIAL PRIMARY KEY,
			user_id TEXT NOT NULL,
			sale_id INTEGER NOT NULL REFERENCES sales(id),
			item_id TEXT NOT NULL,
			code TEXT NOT NULL UNIQUE, -- Ensure codes are unique
			created_at TIMESTAMP NOT NULL DEFAULT NOW(),
			used BOOLEAN NOT NULL DEFAULT FALSE
		)
	`)
	if err != nil {
		log.Printf("Failed to create checkout_attempts table: %v", err)
		return fmt.Errorf("failed to create checkout_attempts table: %w", err)
	}

	// SQL statement to create the 'purchases' table.
	// This table records successful purchases, linking them to a user,
	// sale, item, and the corresponding checkout attempt.
	_, err = pm.DB.Exec(`
		CREATE TABLE IF NOT EXISTS purchases (
			id SERIAL PRIMARY KEY,
			user_id TEXT NOT NULL,
			sale_id INTEGER NOT NULL REFERENCES sales(id),
			item_id TEXT NOT NULL,
			checkout_id INTEGER REFERENCES checkout_attempts(id), -- Optional foreign key to checkout attempt
			created_at TIMESTAMP NOT NULL DEFAULT NOW()
		)
	`)
	if err != nil {
		log.Printf("Failed to create purchases table: %v", err)
		return fmt.Errorf("failed to create purchases table: %w", err)
	}

	log.Println("PostgreSQL tables initialized successfully.")
	return nil
}

// EnsureSaleExists checks if a sale with the given ID already exists in the `sales` table.
// If it does not exist, a new sale record with that ID is created.
// This is useful for idempotent creation of sale records, especially during
// application startup or reconciliation.
//
// Parameters:
//
//	saleID int: The ID of the sale to check or create.
//
// Returns:
//
//	error: An error if there's a database issue during the check or insert, otherwise nil.
func (pm *PostgresManager) EnsureSaleExists(saleID int) error {
	// Check if the sale exists
	var exists bool
	err := pm.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM sales WHERE id = $1)", saleID).Scan(&exists)
	if err != nil {
		log.Printf("Failed to check if sale ID %d exists: %v", saleID, err)
		return fmt.Errorf("failed to check sale existence: %w", err)
	}

	// If the sale doesn't exist, create it
	if !exists {
		_, err = pm.DB.Exec("INSERT INTO sales (id, created_at) VALUES ($1, NOW())", saleID)
		if err != nil {
			log.Printf("Failed to create sale with ID %d: %v", saleID, err)
			return fmt.Errorf("failed to create sale: %w", err)
		}
		log.Printf("Created new sale with ID: %d", saleID)
	}
	return nil
}

// CreateSale inserts a new sale record into the `sales` table with the current timestamp.
// The `id` is auto-generated by the database as a serial primary key.
//
// Returns:
//
//	int: The ID of the newly created sale.
//	error: An error if the insertion fails, otherwise nil.
func (pm *PostgresManager) CreateSale() (int, error) {
	var saleID int
	err := pm.DB.QueryRow("INSERT INTO sales (created_at) VALUES (NOW()) RETURNING id").Scan(&saleID)
	if err != nil {
		log.Printf("Failed to create sale: %v", err)
		return 0, fmt.Errorf("failed to create sale: %w", err)
	}
	log.Printf("New sale created with ID: %d", saleID)
	return saleID, nil
}

// GetCurrentSaleID retrieves the ID of the most recently created sale that is still active
// (i.e., `ended_at` is NULL). If no active sale is found, a new sale is created and its
// ID is returned.
//
// Returns:
//
//	int: The ID of the current (or newly created) active sale.
//	error: An error if there's a database query issue or failure to create a new sale.
func (pm *PostgresManager) GetCurrentSaleID() (int, error) {
	var saleID int
	err := pm.DB.QueryRow(
		"SELECT id FROM sales WHERE ended_at IS NULL ORDER BY created_at DESC LIMIT 1",
	).Scan(&saleID)

	if err != nil {
		if err == sql.ErrNoRows {
			log.Println("No active sale found, creating a new one.")
			return pm.CreateSale() // No active sale, create one
		}
		log.Printf("Failed to get current sale ID: %v", err)
		return 0, fmt.Errorf("failed to get current sale ID: %w", err)
	}

	return saleID, nil
}

// EndSale updates the `ended_at` timestamp for a specific sale, marking it as concluded.
//
// Parameters:
//
//	saleID int: The ID of the sale to be ended.
//
// Returns:
//
//	error: An error if the update fails, otherwise nil.
func (pm *PostgresManager) EndSale(saleID int) error {
	res, err := pm.DB.Exec("UPDATE sales SET ended_at = NOW() WHERE id = $1", saleID)
	if err != nil {
		log.Printf("Failed to end sale ID %d: %v", saleID, err)
		return fmt.Errorf("failed to end sale: %w", err)
	}
	rowsAffected, _ := res.RowsAffected()
	if rowsAffected == 0 {
		log.Printf("Warning: No sale found with ID %d to end.", saleID)
	} else {
		log.Printf("Sale ID %d ended successfully.", saleID)
	}
	return nil
}

// CreateCheckoutAttempt records a new checkout attempt in the `checkout_attempts` table.
// It stores the user ID, sale ID, item ID, and a unique checkout code.
//
// Parameters:
//
//	userID string: The ID of the user attempting checkout.
//	saleID int: The ID of the current flash sale.
//	itemID string: The ID of the item being checked out.
//	code string: The unique checkout code generated for this attempt.
//
// Returns:
//
//	int: The ID of the newly created checkout attempt record.
//	error: An error if the insertion fails, otherwise nil.
func (pm *PostgresManager) CreateCheckoutAttempt(userID string, saleID int, itemID, code string) (int, error) {
	var attemptID int
	err := pm.DB.QueryRow(
		"INSERT INTO checkout_attempts (user_id, sale_id, item_id, code, created_at) VALUES ($1, $2, $3, $4, NOW()) RETURNING id",
		userID, saleID, itemID, code,
	).Scan(&attemptID)

	if err != nil {
		log.Printf("Failed to create checkout attempt for user %s, item %s, code %s: %v", userID, itemID, code, err)
		return 0, fmt.Errorf("failed to create checkout attempt: %w", err)
	}

	return attemptID, nil
}

// MarkCheckoutAttemptAsUsed updates the `used` status of a checkout attempt to TRUE
// for the given checkout code. This prevents the same code from being used multiple times.
//
// Parameters:
//
//	code string: The unique checkout code to mark as used.
//
// Returns:
//
//	error: An error if the update fails, otherwise nil.
func (pm *PostgresManager) MarkCheckoutAttemptAsUsed(code string) error {
	_, err := pm.DB.Exec("UPDATE checkout_attempts SET used = TRUE WHERE code = $1", code)
	if err != nil {
		log.Printf("Failed to mark checkout attempt with code %s as used: %v", code, err)
		return fmt.Errorf("failed to mark checkout attempt as used: %w", err)
	}

	return nil
}

// GetCheckoutAttempt retrieves the details of a checkout attempt by its unique code,
// but only if it has not yet been marked as `used`.
//
// Parameters:
//
//	code string: The unique checkout code.
//
// Returns:
//
//	int: The ID of the checkout attempt.
//	string: The user ID associated with the attempt.
//	int: The sale ID associated with the attempt.
//	string: The item ID associated with the attempt.
//	error: Returns `sql.ErrNoRows` if the code is not found or already used,
//	       or a general error if the query fails.
func (pm *PostgresManager) GetCheckoutAttempt(code string) (int, string, int, string, error) {
	var id int
	var userID string
	var saleID int
	var itemID string

	err := pm.DB.QueryRow(
		"SELECT id, user_id, sale_id, item_id FROM checkout_attempts WHERE code = $1 AND used = FALSE",
		code,
	).Scan(&id, &userID, &saleID, &itemID)

	if err != nil {
		if err == sql.ErrNoRows {
			return 0, "", 0, "", fmt.Errorf("checkout attempt not found or already used for code: %s", code)
		}
		log.Printf("Failed to get checkout attempt for code %s: %v", code, err)
		return 0, "", 0, "", fmt.Errorf("failed to get checkout attempt: %w", err)
	}

	return id, userID, saleID, itemID, nil
}

// CreatePurchase records a new successful purchase in the `purchases` table.
// It links the purchase to the user, sale, item, and the specific checkout attempt.
//
// Parameters:
//
//	userID string: The ID of the user who made the purchase.
//	saleID int: The ID of the sale the purchase belongs to.
//	itemID string: The ID of the item purchased.
//	checkoutID int: The ID of the associated checkout attempt.
//
// Returns:
//
//	int: The ID of the newly created purchase record.
//	error: An error if the insertion fails, otherwise nil.
func (pm *PostgresManager) CreatePurchase(userID string, saleID int, itemID string, checkoutID int) (int, error) {
	var purchaseID int
	err := pm.DB.QueryRow(
		"INSERT INTO purchases (user_id, sale_id, item_id, checkout_id, created_at) VALUES ($1, $2, $3, $4, NOW()) RETURNING id",
		userID, saleID, itemID, checkoutID,
	).Scan(&purchaseID)

	if err != nil {
		log.Printf("Failed to create purchase for user %s, item %s, checkout %d: %v", userID, itemID, checkoutID, err)
		return 0, fmt.Errorf("failed to create purchase: %w", err)
	}

	return purchaseID, nil
}

// GetSaleTotal retrieves the total number of items purchased for a given sale ID.
//
// Parameters:
//
//	saleID int: The ID of the sale.
//
// Returns:
//
//	int: The total count of purchases for the specified sale.
//	error: An error if the query fails, otherwise nil.
func (pm *PostgresManager) GetSaleTotal(saleID int) (int, error) {
	var total int
	err := pm.DB.QueryRow(
		"SELECT COUNT(*) FROM purchases WHERE sale_id = $1",
		saleID,
	).Scan(&total)

	if err != nil {
		log.Printf("Failed to get total purchases for sale ID %d: %v", saleID, err)
		return 0, fmt.Errorf("failed to get sale total: %w", err)
	}

	return total, nil
}

// GetUserPurchases retrieves the number of items purchased by a specific user
// within a given sale.
//
// Parameters:
//
//	userID string: The ID of the user.
//	saleID int: The ID of the sale.
//
// Returns:
//
//	int: The count of purchases made by the user in that sale.
//	error: An error if the query fails, otherwise nil.
func (pm *PostgresManager) GetUserPurchases(userID string, saleID int) (int, error) {
	var total int
	err := pm.DB.QueryRow(
		"SELECT COUNT(*) FROM purchases WHERE user_id = $1 AND sale_id = $2",
		userID, saleID,
	).Scan(&total)

	if err != nil {
		log.Printf("Failed to get purchases for user %s in sale %d: %v", userID, saleID, err)
		return 0, fmt.Errorf("failed to get user purchases: %w", err)
	}

	return total, nil
}

// GetUnusedCheckoutAttempts retrieves all checkout attempts that have not yet been used
// and were created within the last hour. This is primarily for reconciliation purposes.
//
// Returns:
//
//	[]struct{...}: A slice of anonymous structs, each containing the ID, UserID, SaleID,
//	               ItemID, and Code of an unused checkout attempt.
//	error: An error if the query fails, otherwise nil.
func (pm *PostgresManager) GetUnusedCheckoutAttempts() ([]struct {
	ID     int
	UserID string
	SaleID int
	ItemID string
	Code   string
}, error) {
	// Query for attempts created within the last hour and not yet used.
	rows, err := pm.DB.Query(
		"SELECT id, user_id, sale_id, item_id, code FROM checkout_attempts WHERE used = FALSE AND created_at > $1",
		time.Now().Add(-time.Hour), // Only get attempts from the last hour
	)
	if err != nil {
		log.Printf("Failed to get unused checkout attempts: %v", err)
		return nil, fmt.Errorf("failed to get unused checkout attempts: %w", err)
	}
	defer rows.Close() // Ensure rows are closed to release database resources.

	var attempts []struct {
		ID     int
		UserID string
		SaleID int
		ItemID string
		Code   string
	}

	for rows.Next() {
		var attempt struct {
			ID     int
			UserID string
			SaleID int
			ItemID string
			Code   string
		}

		err := rows.Scan(&attempt.ID, &attempt.UserID, &attempt.SaleID, &attempt.ItemID, &attempt.Code)
		if err != nil {
			log.Printf("Failed to scan checkout attempt row: %v", err)
			return nil, fmt.Errorf("failed to scan checkout attempt: %w", err)
		}

		attempts = append(attempts, attempt)
	}

	if err = rows.Err(); err != nil {
		log.Printf("Error during iteration of unused checkout attempts: %v", err)
		return nil, fmt.Errorf("error during iteration of unused checkout attempts: %w", err)
	}

	return attempts, nil
}

// GetCheckoutCodes retrieves all unique checkout codes that are currently unused
// and were created within the last hour.
//
// Returns:
//
//	[]string: A slice of unique checkout codes.
//	error: An error if the query fails, otherwise nil.
func (pm *PostgresManager) GetCheckoutCodes() ([]string, error) {
	rows, err := pm.DB.Query(
		"SELECT code FROM checkout_attempts WHERE used = FALSE AND created_at > $1",
		time.Now().Add(-time.Hour), // Only get codes from attempts in the last hour
	)
	if err != nil {
		log.Printf("Failed to get checkout codes: %v", err)
		return nil, fmt.Errorf("failed to get checkout codes: %w", err)
	}
	defer rows.Close()

	var codes []string

	for rows.Next() {
		var code string

		err := rows.Scan(&code)
		if err != nil {
			log.Printf("Failed to scan checkout code row: %v", err)
			return nil, fmt.Errorf("failed to scan checkout code: %w", err)
		}

		codes = append(codes, code)
	}

	if err = rows.Err(); err != nil {
		log.Printf("Error during iteration of checkout codes: %v", err)
		return nil, fmt.Errorf("error during iteration of checkout codes: %w", err)
	}

	return codes, nil
}

// BeginTransaction starts a new SQL transaction.
// This allows for a series of database operations to be treated as a single,
// atomic unit, ensuring atomicity and consistency.
//
// Returns:
//
//	*sql.Tx: The newly created transaction object.
//	error: An error if starting the transaction fails.
func (pm *PostgresManager) BeginTransaction() (*sql.Tx, error) {
	tx, err := pm.DB.Begin()
	if err != nil {
		log.Printf("Failed to begin transaction: %v", err)
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	return tx, nil
}
